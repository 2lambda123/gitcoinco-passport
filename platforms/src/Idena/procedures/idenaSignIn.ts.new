import crypto from "crypto";
import NodeCache from "node-cache";
import axios, { AxiosInstance } from "axios";

// Idena SignIn session
type Session = {
  // Unique internal ID of the session
  token: string;
  // Randomly generated nonce which Idena app signs with users private key
  nonce?: string;
  // Identity address provided by Idena app
  address?: string;
  // Nonce signature provided by Idena app
  signature?: string;
  cachedExpirationDate?: string;
};

// Idena API url
const API_URL = process.env.NEXT_PUBLIC_IDENA_API_URL;

class PlatformSessionCache<SessionType> {
  private cache: NodeCache;
  longTTL: number = 60;
  shortTTL: number = 10;

  constructor() {
    this.cache = new NodeCache({
      stdTTL: this.longTTL,
      checkperiod: 30,
      maxKeys: 10000,
    });
  }

  initiateSession(clientId: string, initialValue: SessionType): void {
    this.cache.set(clientId, initialValue, this.longTTL);
  }

  getSession(clientId: string): SessionType {
    if (!this.cache.has(clientId)) {
      throw new Error(`Session with id ${clientId} not found`);
    }
    return this.cache.get(clientId);
  }

  updatePreAuthSession(clientId: string, sessionUpdates: Partial<SessionType>): void {
    this._updateSession(clientId, sessionUpdates, this.longTTL);
  }

  updatePostAuthSession(clientId: string, sessionUpdates: Partial<SessionType>): void {
    this._updateSession(clientId, sessionUpdates, this.shortTTL);
  }

  _updateSession(clientId: string, sessionUpdates: Partial<SessionType>, ttl: number): void {
    const currentSession = this.getSession(clientId);
    this.cache.set(clientId, { ...currentSession, ...sessionUpdates }, ttl);
  }
}

// Map <Token, Session>
const sessions = new PlatformSessionCache<Session>();

const generateToken = (): string => {
  return `idena-${crypto.randomBytes(32).toString("hex")}`;
};

const generateNonce = (): string => {
  return `signin-${crypto.randomBytes(32).toString("hex")}`;
};

export const initSession = (): string => {
  const token = generateToken();

  sessions.initiateSession(token, {
    token,
  });

  return token;
};

export const startIdenaSession = (token: string, address: string): string | undefined => {
  const session = sessions.getSession(token);
  if (!session || session.nonce) {
    return;
  }
  session.nonce = generateNonce();
  session.address = address;
  return session.nonce;
};

export const authenticate = async (token: string, signature: string): Promise<boolean> => {
  const session = sessions.getSession(token);
  if (!session || !session.address || session.signature) {
    return;
  }
  let address;
  try {
    address = await requestSignatureAddress(session.nonce, signature);
  } catch (e) {
    return false;
  }
  if (!address || address.toLowerCase() !== session.address.toLowerCase()) {
    return false;
  }
  session.signature = signature;
  return true;
};

type SignatureAddressResponse = {
  result: string;
};

type EpochResponse = {
  result: { validationTime: string };
};

type IdentityResponse = {
  result: { state: string };
  address: string;
};

type IdentityAgeResponse = {
  result: string;
  address: string;
};

type AddressResponse = {
  result: { stake: string };
  address: string;
};

const requestSignatureAddress = async (nonce: string, signature: string): Promise<string> => {
  const response: { data: SignatureAddressResponse } = await apiClient().get(
    `/api/SignatureAddress?value=${nonce}&signature=${signature}`
  );
  return response.data.result;
};

const requestValidationTime = async (token: string): Promise<string> => {
  const session = sessions.getSession(token);
  if (!session.cachedExpirationDate) {
    const data: EpochResponse = await apiClient().get("/api/epoch/last");
    session.cachedExpirationDate = data.result.validationTime;
  }
  return session.cachedExpirationDate;
};

export const requestIdentityState = async (
  token: string
): Promise<{ address: string; state: string; expirationDate: string }> => {
  const data: IdentityResponse = await request(token, "/api/identity/_address_");
  const expirationDate = await requestValidationTime(token);
  return { address: data.address, state: data.result.state, expirationDate };
};

export const requestIdentityAge = async (
  token: string
): Promise<{ address: string; age: number; expirationDate: string }> => {
  const data: IdentityAgeResponse = await request(token, "/api/identity/_address_/age");
  const expirationDate = await requestValidationTime(token);
  return { address: data.address, age: +data.result, expirationDate };
};

export const requestIdentityStake = async (
  token: string
): Promise<{ address: string; stake: number; expirationDate: string }> => {
  const data: AddressResponse = await request(token, "/api/address/_address_");
  const expirationDate = await requestValidationTime(token);
  return { address: data.address, stake: +data.result.stake, expirationDate };
};

const apiClient = (): AxiosInstance => {
  return axios.create({
    baseURL: API_URL,
  });
};

const request = async <SessionType>(token: string, method: string): Promise<SessionType> => {
  const session = findSession(token);
  if (!session.signature) {
    throw "authentication not passed";
  }
  method = method.replace("_address_", session.address);

  const response = await apiClient().get(method);

  if (response.status != 200) {
    throw `get ${method} returned status code ${response.status} instead of the expected 200`;
  }
  return { ...response.data, address: session.address } as SessionType;
};
